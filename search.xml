<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node基础</title>
      <link href="/2022/05/13/node/node%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/13/node/node%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>  此文档是之前学习前端记录，后续我将进行格式修改。</p><h1 id="初始node-js"><a href="#初始node-js" class="headerlink" title="初始node.js"></a>初始node.js</h1><div class="hljs code-wrapper"><pre><code class="hljs">   v8解析引擎负责解析执行javascript代码；   内置API是由运行环境提供的特殊接口，只能在所在的运行环境中调用。</code></pre></div><h1 id="什么是node-js"><a href="#什么是node-js" class="headerlink" title="什么是node.js"></a>什么是node.js</h1><div class="hljs code-wrapper"><pre><code class="hljs">  node.js是基于Chrome的V8引擎的javascript的运行环境  注意：      浏览器是javascript的前端运行环境；      node.js是javascript的后端运行环境      node.js无法调用DOM、bom等操作</code></pre></div><h1 id="node-js可以做什么"><a href="#node-js可以做什么" class="headerlink" title="node.js可以做什么"></a>node.js可以做什么</h1><div class="hljs code-wrapper"><pre><code class="hljs">  node.js作为一个javascript的运行环境，仅仅提供了基础的功能和API，然而基于node.js的工具和框架层出不穷。        可以基于Express框架，快速构建WEB应用        可以基于Electron框架，可以构建跨平台桌面应用        可以基于restify框架，快速构建API接口项目        可以读写数据库和操作数据库、创建实用命令行工具辅助前端开发</code></pre></div><h1 id="在node-js环境中执行javascript代码"><a href="#在node-js环境中执行javascript代码" class="headerlink" title="在node.js环境中执行javascript代码"></a>在node.js环境中执行javascript代码</h1><div class="hljs code-wrapper"><pre><code class="hljs">   打开终端，输入node+执行代码文件位置</code></pre></div><h1 id="fs文件系统模块"><a href="#fs文件系统模块" class="headerlink" title="fs文件系统模块"></a>fs文件系统模块</h1><div class="hljs code-wrapper"><pre><code class="hljs">    fs模块是node官方提供用来操作文件的模块。它提供一系列方法和属性，用来满足用户对文件的操作需求      使用步骤：       首先导入fs模块文件            const fs=rquire(&#39;fs&quot;)        读取文件fs.readFile()方法        写入文件fs.readFile()方法</code></pre></div><h1 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h1><div class="hljs code-wrapper"><pre><code class="hljs">   读取文件会传入三个参数：    第一个参数为文件所在位置    第二个为读取文件时采用的编码格式，一般默认指定为UTF-8    第三个参数为回调函数，拿到读取失败和成功的结果   err datastr    读取成功err参数就为null，读取失败datastr就为undefind 例如：fs.readFile(&#39;./file.txt&#39;,&#39;utf-8&#39;,(err,datastr)=&gt;&#123;           console.log(err)           console.log(&#39;------------&#39;)           //打印成功读取文件的结果           console.log(datastr)       &#125;)</code></pre></div><h1 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h1><div class="hljs code-wrapper"><pre><code class="hljs">   该方法会传入三个参数       第一个参数为要写入文件的位置       第二个参数为要写入的内容       第三个参数为回调函数            回调函数会传入一个参数err            如果文件写入 成功，则err参数的值为null            如果文件写入失败，则err的值等于一个错误对象  例如：    fs.writeFile(&#39;./file.txt&#39;,&#39;我想学习&#39;,(err)=&gt;&#123;         console.log(err)    &#125;)  注意：   这个方法只能用来创建文件，不能用来创建路径   新写入内容会覆盖旧内容</code></pre></div><h1 id="fs文件模块路径"><a href="#fs文件模块路径" class="headerlink" title="fs文件模块路径"></a>fs文件模块路径</h1><div class="hljs code-wrapper"><pre><code class="hljs">  fs文件模块会根据命令终端所在的目录动态拼接出操作文件的完整路径   那么这样就会出现问题：     当我们文件路径以./或者在../的相对路径形式，那么在不同文件下执行命令就会出现路径问题  解决方法：1、使用绝对路径（可移植性差）           2、使用__dirname 来表示当前文件目录 例如用 __dirname+&#39;/file.txt&#39;</code></pre></div><h1 id="path路径模块"><a href="#path路径模块" class="headerlink" title="path路径模块"></a>path路径模块</h1><div class="hljs code-wrapper"><pre><code class="hljs"> path模块是node.js官方提供的、用来处理路径的模块，他提供的一系列模块可以满足用户对路径处理的需求 例如：path.join(),用来拼接成一个完整的路径字符串      path.basename()。用来从路径字符串中将文件名解析出来      path.extname(),获取路径扩展路径 以后文件路径拼接时，就要使用path.join() 例如：const pathStr=path.join(__dirname,&#39;./111&#39;)</code></pre></div><h1 id="获取路径中的名字部分"><a href="#获取路径中的名字部分" class="headerlink" title="获取路径中的名字部分"></a>获取路径中的名字部分</h1><div class="hljs code-wrapper"><pre><code class="hljs">  const pathBasename=path.basename(&#39;/a/b/d/c&#39;)  打印pathBasename为c</code></pre></div><h1 id="什么是http模块"><a href="#什么是http模块" class="headerlink" title="什么是http模块"></a>什么是http模块</h1><div class="hljs code-wrapper"><pre><code class="hljs">在网络节点中，负责消费资源的交=叫客户端，负责对外提供网络资源的电脑叫服务器http模块是node.js官方提供的、用来创建web服务器的模块。通过http模块提供的方法，就能方便的把一台普通的电脑变成一台web服务器，从而向外界提供web资源服务器与普通电脑的区别在于，服务器上安装了web服务器软件，例如apache等，通过这些服务器软件，就能把一台普通的电脑变为一台web服务器在node.js中，不需要第三方服务器软件，我们可以使用node.js提供的http模块</code></pre></div><h1 id="服务器相关概念"><a href="#服务器相关概念" class="headerlink" title="服务器相关概念"></a>服务器相关概念</h1><div class="hljs code-wrapper"><pre><code class="hljs">#ip地址    IP地址具有唯一性；    互联网中每个web服务器，都有自己的IP地址，都可以通过ip地址找到相应的网站#域名和域名服务器    IP地址能够唯一标识在网络中的计算机，但是IP地址是一长串数字，不直观，不便于记忆，于是域名地址解决这一问题    ip地址和域名是一一对应的关系，这份对应关系保存在域名服务器中（DNS）     注意：        单纯使用IP地址，在互联网中的电脑也能够正常使用，互联网中的电脑有了域名的加持，变得更加方便        在开发测试中，127.0.0.1对应的域名是localhost#端口号    在一台电脑中可以运行成千上万个服务器，但是每个服务器对应唯一个端口号，通过端口号可以准确交到指定    服务器处理   </code></pre></div><h1 id="创建最基本的web服务器步骤"><a href="#创建最基本的web服务器步骤" class="headerlink" title="创建最基本的web服务器步骤"></a>创建最基本的web服务器步骤</h1><div class="hljs code-wrapper"><pre><code class="hljs">   第一步导入http模块   第二步创建web服务器实例   第三步为服务器绑定request事件，监听客户端请求   第四步启动服务器     const http=require(&#39;http&#39;)     //创建web服务器实例      const server=http.createServer()     //为服务器绑定request事件，监听客户端请求     server.on(&#39;request&#39;,(req,res)=&gt;&#123;       console.log(&#39;服务器被调用&#39;)     &#125;)    //启动服务器    server.listen(9000,()=&gt;&#123;      console.log(&#39;服务启动成功&#39;)    &#125;)</code></pre></div><h1 id="req对象"><a href="#req对象" class="headerlink" title="req对象"></a>req对象</h1><div class="hljs code-wrapper"><pre><code class="hljs">  只要服务器接收到了客户端的请求，就会通过server.on()为服务器绑定request事件处理函数     req是请求对象，他包含了与客户端相关的属性与数据     req.url是客户端请求的地址     req.method是客户端的method请求类型</code></pre></div><h1 id="res对象"><a href="#res对象" class="headerlink" title="res对象"></a>res对象</h1><div class="hljs code-wrapper"><pre><code class="hljs">  res是应答对象</code></pre></div><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><div class="hljs code-wrapper"><pre><code class="hljs"> 模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干个模块的过程。对于整个系统来说，模块是可组合、 可分解和更换的单元    好处：      提高了代码的复用性      提高了代码的可维护性      可以实现按需加载</code></pre></div><h1 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h1><div class="hljs code-wrapper"><pre><code class="hljs">内置模块   （内置模块是由node.js官方提供的如fs文件模块、path路径模块、http模块）自定义模块第三方模块   </code></pre></div><h1 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h1><div class="hljs code-wrapper"><pre><code class="hljs">   使用require()方法可以加载需要的内置模块、用户自定义模块、第三方模块使用   加载自定义模块时，需要加路径</code></pre></div><h1 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h1><h1 id="向外共享模块作用域的成员"><a href="#向外共享模块作用域的成员" class="headerlink" title="向外共享模块作用域的成员"></a>向外共享模块作用域的成员</h1><div class="hljs code-wrapper"><pre><code class="hljs">  使用require方法导入模块时，导入的结果永远以module.exports指向的对象为准   由于module.exports单词写起来比较复杂，为了简化向外共享成员代码时，node提供   了exports对象。默认情况下，exports和module.exports指向同一个对象，最终指向的结果还是以   module.exports指向的对象为准</code></pre></div><h1 id="module-exports与export使用误区"><a href="#module-exports与export使用误区" class="headerlink" title="module.exports与export使用误区"></a>module.exports与export使用误区</h1><div class="hljs code-wrapper"><pre><code class="hljs">   require方法导入模块时，导入的结果永远以module.exports指向的对象为准</code></pre></div><h1 id="node-js中的模块化规范"><a href="#node-js中的模块化规范" class="headerlink" title="node.js中的模块化规范"></a>node.js中的模块化规范</h1><div class="hljs code-wrapper"><pre><code class="hljs"> node.js遵循了commonJs规范，commonJs规定了模块的特性和各个模块之间相互依赖  commonJs规定：   1.每个模块内部，module变量代表当前模块   2.module变量是一个对象，他的export属性是对外的接口   3.加载某个模块时，其实是加载该模块module.exports的属性，require()方法用于加载模块</code></pre></div><h1 id="node-js中的第三方模块又叫做包"><a href="#node-js中的第三方模块又叫做包" class="headerlink" title="node.js中的第三方模块又叫做包"></a>node.js中的第三方模块又叫做包</h1><div class="hljs code-wrapper"><pre><code class="hljs">     就像电脑与计算机是相同的东西     由于node.js的内置模块仅仅提供了一些底层的API，导致在基于内置模块进行项目开发时，效率很低     包是基于内置模块封装出来的、提供了更高级、更方便的API、极大的提高了开发效率</code></pre></div><h1 id="包管理配置文件"><a href="#包管理配置文件" class="headerlink" title="包管理配置文件"></a>包管理配置文件</h1><div class="hljs code-wrapper"><pre><code class="hljs">    在npm中规定，在项目根目录中，必须提供一个叫做package.json的包管理配置文件，用来记录    与项目有关的一些配置信息，例如：       项目的名称、版本号、描述       项目中用到了那些包       那些包在开发中会用到       那些包在开发和部署时都会用到</code></pre></div><h1 id="创建包管理配置文件"><a href="#创建包管理配置文件" class="headerlink" title="创建包管理配置文件"></a>创建包管理配置文件</h1><div class="hljs code-wrapper"><pre><code class="hljs">  --npm提供了一个快捷命令，可以执行命令在所处目录中，快速创建package.json包管理配置文件      npm init -y  --package.json包管理文件中的dependencies节点表示使用npm i命令装了那些包    devDependencies节点表示某些包只会在开发阶段使用的包，，而在项目上线之后不会用到，则建议将这些包记录到 devDependencies    节点中，如果包在开发和上线之后都需要使用时，建议把这些包记录到dependencies节点中  --安装包npm i    卸载包npm uninstall        安装指定的包，并记录到devDependencies节点中   npm i 包名 --save--dev（简写npm i 包名 -D）</code></pre></div><h1 id="包的分类"><a href="#包的分类" class="headerlink" title="包的分类"></a>包的分类</h1><div class="hljs code-wrapper"><pre><code class="hljs">   包分为项目开发包，全局包        全局包：              只有工具性质的包，才有全局安装的必要性              包会安装到C:\Users\asus\AppData\Roaming\npm\node_modules下              npm i 包名 -g        项目开发包：           开发依赖包           核心依赖包</code></pre></div><h1 id="发布npm包"><a href="#发布npm包" class="headerlink" title="发布npm包"></a>发布npm包</h1><div class="hljs code-wrapper"><pre><code class="hljs">  把终端切换到包的根目录中时，运行npm publish命令。即可发布到npm上（包名不能雷同）  运行npm unpublish 包名 --force命令，即可从npm 删除已发布的包（仅可删除上传72小时以内的包）  删除的包24小时内不能重新上传</code></pre></div><h1 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h1><div class="hljs code-wrapper"><pre><code class="hljs">  优先从缓存中加载，模块第一次加载之后会被后台缓存，这也意味着多次调用require()不会导致模块代码执行  多次，注意，无论是内置模块、用户自定义模块、还是第三方模块，他们都会优先从缓存中加载，从而提高加载效率    内置模块是node.js官方提供的，所以内置模块的优先级最高  使用自定义模块时，必须加./路径标识符，否则node将会当作内置模块或第三方模块  如果是第三方模块会尝试从node_modules文件夹中寻找，没有找到就会移动到上一层目录中，直至文件根目录  </code></pre></div><h1 id="express"><a href="#express" class="headerlink" title="express"></a>express</h1><div class="hljs code-wrapper"><pre><code class="hljs">  express是基于node.js平台，快速、开放、极简的web开发框架  express的作用与node.js内置模块类似，专门用来创建web服务器  express本质：就是一个npm上的第三方包，提供了快速创建web服务器的便捷方法</code></pre></div><h1 id="express能做什么"><a href="#express能做什么" class="headerlink" title="express能做什么"></a>express能做什么</h1><div class="hljs code-wrapper"><pre><code class="hljs">  使用express，我们可以方便、快速创建web网站服务器或API接口的服务器</code></pre></div><h1 id="express基本使用"><a href="#express基本使用" class="headerlink" title="express基本使用"></a>express基本使用</h1><div class="hljs code-wrapper"><pre><code class="hljs">  //导入express  //创建web服务器实例  //启动web服务器    //导入express    const express=require(&#39;express&#39;)    //创建web服务器实例    const app=express()    //启动web服务器    app.listen(9000,()=&gt;&#123;      console.log(&#39;express搭建的服务器好了&#39;)    &#125;)</code></pre></div><h1 id="监听客户端GET请求，post请求"><a href="#监听客户端GET请求，post请求" class="headerlink" title="监听客户端GET请求，post请求"></a>监听客户端GET请求，post请求</h1><div class="hljs code-wrapper"><pre><code class="hljs"> 调用app.get()方法，使用res.send()发送应答     //监听客户端GET请求      app.get(&#39;/user&#39;,(req,res)=&gt;&#123;        //向客户端发送json对象        res.send(&#123;name:&#39;hezhixing&#39;&#125;)      &#125;)   调用app.post()方法，使用res.send()发送应答        //监听客户端POST请求        app.post(&#39;/user&#39;,(req,res)=&gt;&#123;          res.send(&#39;请求成功&#39;)        &#125;)</code></pre></div><h1 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h1><div class="hljs code-wrapper"><pre><code class="hljs"> res.send()应答响应 req.query请求参数 req.params对象，可以访问到url，通过：匹配到动态参数         //注意这里的：id是一个动态的id        app.get(&#39;/user/:id&#39;,(req,res)=&gt;&#123;          console.log(req.params)          res.send(req.params)        &#125;)</code></pre></div><h1 id="express-staic"><a href="#express-staic" class="headerlink" title="express.staic"></a>express.staic</h1><div class="hljs code-wrapper"><pre><code class="hljs">  静态资源，express提供了非常好用的函数，叫做express.static(),通过它，我们可以非常  方便地创建一个静态资源服务器，例如，通过如下代码就可以将public目录下的图片、css文件  js文件对外开放访问：         app.use(express.static(&#39;public&#39;))  注意：express在指定静态目录下查找文件，存放静态文件的目录名不会出现在url中    //导入express    const express=require(&#39;express&#39;)    //创建web服务器实例    const app=express()    //调用express.static()方法，来对外提供那个静态资源    app.use(express.static(&#39;./clock&#39;))    //启动web服务器实例    app.listen(9000,()=&gt;&#123;      console.log(&#39;web服务器启动成功！&#39;)    &#125;)</code></pre></div><h1 id="托管多个静态资源目录"><a href="#托管多个静态资源目录" class="headerlink" title="托管多个静态资源目录"></a>托管多个静态资源目录</h1><div class="hljs code-wrapper"><pre><code class="hljs">  调用多次express.static方法 ,但是该方法会根据顺序查找，    app.use(&#39;file&#39;,express.static(&#39;./files&#39;))    app.use(&#39;clock&#39;,express.static(&#39;./clock&#39;))    加载时，要加访问前缀</code></pre></div><h1 id="express路由"><a href="#express路由" class="headerlink" title="express路由"></a>express路由</h1><div class="hljs code-wrapper"><pre><code class="hljs">   路由广义上来讲，就是映射关系   在express中，路由指的是客户端请求与服务器处理函数之间的映射关系。   Express的路由由三部分组成，分别是请求的类型、请求的url地址、处理函数，格式如下：      app.METHOD(PATH,HANDLER)  例子：         //引入express实例          const express=require(&#39;express&#39;)          //创建expressweb服务          const app=express()          app.get(&#39;/&#39;,(req,res)=&gt;&#123;            console.log(&#39;/路由下被请求&#39;)            res.send(&#39;hello nodejs&#39;)          &#125;)          app.get(&#39;/user&#39;,(req,res)=&gt;&#123;            console.log(&#39;user路由被请求&#39;)            res.send(&#39;我是user路由下的请求&#39;)          &#125;)          //启动web服务器          app.listen(9000,()=&gt;&#123;            console.log(&#39;服务器启动成功&#39;)          &#125;)</code></pre></div><h1 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h1><div class="hljs code-wrapper"><pre><code class="hljs">   每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用相应的处理函数   在匹配时，按路由的顺序进行匹配，如果请求类型和请求的url地址同时匹配成功，则express就会将这次   的请求，转交给对应的function函数进行处理。   按定义的先后顺序进行匹配，如匹配成功就不会再进行匹配</code></pre></div><h1 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h1><div class="hljs code-wrapper"><pre><code class="hljs"> 为了方便对路由进行模块化管理，exprss不建议将路由直接挂载到app上，而是推荐将路由抽离为单独的模块   将路由抽离为单独的模块     1、创建路由，模块对应的js文件     2、调用express.Router()函数创建路由对象     3、向路由对象上挂载具体的路由     4、使用module.exports向外共享路由对象     5、使用app.use()函数注册路由模块     app.use()作用就是注册全局中间件，还可以在此加入访问前缀</code></pre></div><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><div class="hljs code-wrapper"><pre><code class="hljs"> 中间件(middleware), 特指业务流程的中间处理环节 express中间件的调用流程：当请求到达express的服务器之后， 可以调用多个中间件，对这次请求进行预处理</code></pre></div><h1 id="express中间件的格式"><a href="#express中间件的格式" class="headerlink" title="express中间件的格式"></a>express中间件的格式</h1><div class="hljs code-wrapper"><pre><code class="hljs">  express中间件，本质上就是一个function处理函数，express中间件的格式如下：      app.get(path,(req,res,next)=&gt;&#123;        next()      &#125;)        注意:中间件函数的形参列表中，必须包含next函数，而路由处理函数中只包含req,res</code></pre></div><h1 id="next函数的作用"><a href="#next函数的作用" class="headerlink" title="next函数的作用"></a>next函数的作用</h1><div class="hljs code-wrapper"><pre><code class="hljs"> next函数是实现多个中间件连续调用的关键，它表示流转关系转交给下一个中间件或路由,有放行的意思      //引入express模块        const express=require(&#39;express&#39;)        const app=express()        //定义中间件        const mw=(req,res,next)=&gt;&#123;          console.log(&#39;这是一个最简单的中间件函数&#39;)          //把流转关系转交给下一个中间件或路由          next()        &#125;        //注册全局中间件        app.use(mw)        //使用中间件        app.get(&#39;/&#39;,(req,res)=&gt;&#123;          res.send(&#39;HOME page&#39;)        &#125;)        app.get(&#39;/user&#39;,(req,res)=&gt;&#123;          res.send(&#39;User page&#39;)        &#125;)        app.listen(9000,()=&gt;&#123;          console.log(&#39;定义中间件服务器启动&#39;)        &#125;)</code></pre></div><h1 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h1><div class="hljs code-wrapper"><pre><code class="hljs">   多个中间件之间，共享同一份req和res，基于这样的特性，我们可以在上游的中间件统一为req与res对象添加   自定义的属性或方法。供下游中间件或路由进行使用       例如：可以设置req参数，向下游路由或中间件共享该参数，下游可以使用req来访问中间件的设置         //全局中间件简化格式          app.use((req,res,next)=&gt;&#123;            //为req对象挂载，自定义属性，从而把时间共享传递给后面的所有路由            req.starTime=moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)            console.log(&#39;这是定义注册全局中间件&#39;)            next()          &#125;)</code></pre></div><h1 id="定义多个中间件"><a href="#定义多个中间件" class="headerlink" title="定义多个中间件"></a>定义多个中间件</h1><div class="hljs code-wrapper"><pre><code class="hljs">  通过app.use来连续定义多个全局中间件，客户端请求到达服务器以后，会按照中间件定义先后顺序依次进行调用</code></pre></div><h1 id="局部生效的中间件"><a href="#局部生效的中间件" class="headerlink" title="局部生效的中间件"></a>局部生效的中间件</h1><div class="hljs code-wrapper"><pre><code class="hljs">   不使用app.use()注册的中间件，叫做局部生效的中间件        //使用中间件          app.get(&#39;/&#39;,mw,(req,res)=&gt;&#123;            res.send(&#39;HOME page&#39;)          &#125;)</code></pre></div><h1 id="定义多个中间件-1"><a href="#定义多个中间件-1" class="headerlink" title="定义多个中间件"></a>定义多个中间件</h1><div class="hljs code-wrapper"><pre><code class="hljs">    在路由中有两种等价的方式    1、app.get(&#39;/&#39;,mw1,mw2,mw3,handler())    2、app.get(&#39;/&#39;,[mw1,mw2,mw3],handler())</code></pre></div><h1 id="中间件使用的5个注意事项"><a href="#中间件使用的5个注意事项" class="headerlink" title="中间件使用的5个注意事项"></a>中间件使用的5个注意事项</h1><div class="hljs code-wrapper"><pre><code class="hljs">   1、一定要在路由之前注册中间件   2、客户端发送过来的请求，可以连续调用多个中间件来进行处理   3、定义中间件时，不要忘记调用next函数，进行放行   4、调用完next函数后，不要在其编写其他代码   5、连续调用多个中间件时，中间件之间是共享req与res对象</code></pre></div><h1 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h1><div class="hljs code-wrapper"><pre><code class="hljs"> express官方将中间件分为了五大类：    1、通过app.use()、app.get()、app.post(),绑定到app实例上的中间件，叫做应用级别中间件    2、路由级别中间件：绑定到express.Router()实例上的中间件，他的用法与应用级别中间件没有任何区别       只不过、应用级别中间件是绑定到app实例上的，路由级别中间件是绑定到router上的    3、错误级别中间件:专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题       格式：错误级别的中间件的function的处理函数中，必须要有四个形参，分别是（err,req,res,next）         例如：             app.get(&#39;/&#39;,(req,res)=&gt;&#123;               throw new Error(&#39;服务器内部发生了错误&#39;)    //抛出自定义错误               res.send(&#39;hello&#39;)             &#125;)             app.use((err,req,res,next)=&gt;&#123;              //错误级别的中间件               console.log(&#39;发生了错误&#39;,err.message)               res.send(&#39;Error&#39;+err.message)             //将收集的异常错误发送给客户端，防止程序异常崩溃             &#125;)      注意错误级别中间件要注册到路由之后，才能捕获异常错误    4、express内置中间件：4.16.0内置了3个内置中间件          express.static()快速托管静态资源的内置中间件，例如HTML、css等等          express.json()解析json格式的请求体数据（4.16后可用）          express.urlencoded()解析url-encoded格式的请求体数据（4.16后可用）          使用内置中间件方法：app.use(express.json())    5、第三方中间件        非express官方内置的中间件，而是由第三方开发出来的中间件叫做第三方中间件，在项目中，大家可以按需下载并配置         例如在express4.16.0之前的版本，经常使用body-parser这个第三方中间件，来解析请求体数据：              1、运行npm i body-parser安装这个中间件              2、使用require导入这个中间件              3、调用app.use()注册并使用中间件</code></pre></div><h1 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h1><div class="hljs code-wrapper"><pre><code class="hljs"> 自己手动模拟一个类似于express.urlencoded这样的中间件，来解析POST提交到服务器的表单数据   实现步骤：       1、定义中间件       2、监听req的data请求       3、监听req的end事件       4、使用querystring模块解析请求体数据       5、将解析好的数据对象挂载到req.body</code></pre></div><h1 id="使用express写接口"><a href="#使用express写接口" class="headerlink" title="使用express写接口"></a>使用express写接口</h1><div class="hljs code-wrapper"><pre><code class="hljs">  1、创建基本的服务器  2、创建api路由模块  3、接口编写  4、跨域问题解决：           有：cors、jsonp(这种有缺陷，只支持get请求)</code></pre></div><h1 id="跨域问题解决"><a href="#跨域问题解决" class="headerlink" title="跨域问题解决"></a>跨域问题解决</h1><div class="hljs code-wrapper"><pre><code class="hljs">  1、cors跨域问题：      cors是express的一个第三方中间件，通过安装和配置cors中间件，可以很方便的解决跨域问题  使用步骤有三步：       1.运行npm i cors安装中间件       2.使用const cors=require(&#39;cors&#39;)导入中间件       3.在路由之前调用app.use(cors())</code></pre></div><h1 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h1><div class="hljs code-wrapper"><pre><code class="hljs"> 什么是cors：英文名称（Cross-origin Resource Sharing）跨域资源共享由一系列http响应头组成，  这些http响应头决定浏览器是否阻止前端js代码跨域获取资源  浏览器同源安全策略会默认阻止网页“跨域”获取资源，但是如果接口服务器配置了cors相关的http响应头  就可以解决跨域问题访问限制。 注意：cors主要在服务器端进行配置，客户端浏览器无需做任何额外的配置，即可请求开启了cors的接口      cors在浏览器中有兼容性，只支持  XMLHttpRequest Level2的浏览器才能正常访问</code></pre></div><h1 id="cors响应头"><a href="#cors响应头" class="headerlink" title="cors响应头"></a>cors响应头</h1><div class="hljs code-wrapper"><pre><code class="hljs">   3个相关的响应头部：       Access-Contorl-Allow-Origin 可以控制那些网站的请求                  例如：res.setHeader(&#39;Access-Contorl-Allow-Origin&#39;,&#39;*&#39;)    //允许所有网站的请求       Access-Contorl-Allow-Headers 默认情况下，cors仅支持客户端发送9个请求头            通过这个可以声明额外的请求头：                       res.setHeader(&#39;Access-Contorl-Allow-Headers&#39;,&#39;Content-Type,X-Custom-Header&#39;)       Access-Contorl-Allow-Methods  默认情况下cors仅支持客户端发起get、post、HEAD请求           如果客户端想要通过PUT、DELELT等方式请求服务器的资源，则需要在服务器端设置指明实际需要的http方法                       res.setHeader(&#39;Access-Contorl-Allow-Methods&#39;,&#39;*&#39;)   //允许所有请求方法           </code></pre></div><h1 id="cors请求的分类"><a href="#cors请求的分类" class="headerlink" title="cors请求的分类"></a>cors请求的分类</h1><div class="hljs code-wrapper"><pre><code class="hljs">   在客户端请求cors接口时，根据请求方式和请求头的不同，可以将cors请求分为两大类：        1、简单请求                请求方式属于get、post、head三者之一，同时请求头在9个范围之内        2、预检请求               只要包含一项就是预检请求                   请求方式是get、post、head三者之外                   请求头包含自定义头部字段                   向服务器发送了application/json格式的请求          什么是预检请求：在浏览器与服务器正式通信之前，浏览器会发送一个OPTION的请求进行预检，以获知                        服务器是否允许实际请求，所以这个OPTION的请求称为预检请求。服务器成功响应预检请求后，                        才会发送真正的请求  简单请求与预检请求的区别：         简单请求：客户端与服务器端之间只会发生一次请求         预检请求：客户端与服务器端会发生两次请求，OPTION预检请求成功之后，才会发起真正的请求</code></pre></div><h1 id="jsonp接口"><a href="#jsonp接口" class="headerlink" title="jsonp接口"></a>jsonp接口</h1><div class="hljs code-wrapper"><pre><code class="hljs">   概念：浏览器端通过&lt;script&gt;标签的src属性，请求服务器上的数据，同时服务器返回一个函数的调用。这种请求数据的方式叫做jsonp   特点：JSONP不属于真正的AJAX请求，因为它没有使用XMLHttpRequest对象        JSONP仅支持GET请求，不支持POST、PUT等请求    创建JSONP接口：         如果项目中已经配置了cors跨域资源共享，为了防止冲突，必须要配置cors中间件之前声明JSONP接口，否则JSONP接口会被处理         成开启了CORS的接口    实现jsonp接口的步骤：           1、获取客户端发送过来的回调函数的名字           2、得到通过jsonp形式发送给客户端的数据           3、根据前两步得到的数据，拼接一个函数调用的字符串           4、把上一步拼接得到的字符串，响应给客户端的&lt;script&gt;标签解析                  //配置JSONP接口，必须要在cors之前配置                  app.get(&#39;/api/jsonp&#39;,(req,res)=&gt;&#123;                    //定义JSONP接口具体实现过程                    //1、获取客户端发送过来的回调函数的名字                    const funcName=req.query.callback                    //2、获取通过jsonp格式发送给客户端的数据                    const data=&#123;name:&#39;zs&#39;,age:19&#125;                    //3、根据前两步得到的数据、拼接出一个函数调用的字符串                    const scriptStr=`$&#123;funcName&#125;($&#123;JSON.stringify(data)&#125;)`                    //4、把上一步拼接的字符串，响应给客户端的&lt;script&gt;标签解析执行                    res.send(scriptStr)                  &#125;)                  //jsonp请求                    $(&quot;#jsonp&quot;).on(&#39;click&#39;,function()&#123;                      $.ajax(&#123;                      type:&#39;GET&#39;,                      url:&quot;http://127.0.0.1:9000/api/jsonp&quot;,                      dataType:&#39;JSONP&#39;,                      success:function(res)&#123;                        console.log(res)                      &#125;                    &#125;)                    &#125;)</code></pre></div><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h1 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h1><div class="hljs code-wrapper"><pre><code class="hljs">     数据库（database）是用来阻组织、存储和管理数据的仓库     为了方便管理互联网数据，就有了数据库管理系统的概念，简称数据库     传统型数据库中，数据的组织结构分为数据库、数据表、数据行、数据列4大部分组成     之间的关系：             1、在实际的开发过程中，一般情况下，每个项目对应独立的数据库             2、在不同的数据，要存储到数据库的不同表中，例如：用户数据存到users表中，图书信息存到books表中             3、每个表具体要存储那些信息，由字段来决定</code></pre></div><h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><div class="hljs code-wrapper"><pre><code class="hljs">  .......</code></pre></div><h1 id="sql增删改查基本使用"><a href="#sql增删改查基本使用" class="headerlink" title="sql增删改查基本使用"></a>sql增删改查基本使用</h1><div class="hljs code-wrapper"><pre><code class="hljs">    1、SQL的SELECT语句：         SELECT语句用于从表中查询数据，执行的结果被存储在一个结构表中，格式如下：              SELECT *FROM 表名称     //查询指定表              SELECT 列名称 FROM 表名称        //从指定表中，查询出指定列的名称的数据   2、SQL的INSERT INTO 语句         INSERT INTO 语句用于向数据表中插入新的数据行，语法格式              INSERT INTO table_name(列1，列2....)VALUES(值1，值2....)    3、SQL中Update语句           Update语句主要运用于修改数据表中的数据，语法格式如下：                  UPDATE 表名称 SET 列名=新值 WHERE 列名称=某值   //修改一列                  UPDATE 表名称 SET 列名=新值, 列名=新值 WHERE 列名称=某值   //修改多个列    4、SQL中DELETE语句           DELETE语句用于删除表中的行，语法格式：                 DELETE FROM 表名称 WHERE 列名称=值    注意：在删除、修改时一定要注意加上WHERE条件</code></pre></div><h1 id="SQL中WHERE子句"><a href="#SQL中WHERE子句" class="headerlink" title="SQL中WHERE子句"></a>SQL中WHERE子句</h1><div class="hljs code-wrapper"><pre><code class="hljs">   WHERE用于限定选择的标准，在SELECT、DELETE、UPDATE语句中均可使用WHERE子句来限定选择的标准         SELECT 列名称 FROM 表名 WHERE 列 运算符 值           //查询语句中的where条件         UPDATE 表名称 SET 列=新值，列=新值 WHERE 列 运算符 值     //更新满足WHERE条件         DELECT FROM 表名称 WHERE 列 运算符 值                    //删除满足WHERE条件的行      其中运算符有=,&lt;,&gt;,&lt;&gt;(不等于),BETWEEN</code></pre></div><h1 id="SQL语句的ADD与OR运算符"><a href="#SQL语句的ADD与OR运算符" class="headerlink" title="SQL语句的ADD与OR运算符"></a>SQL语句的ADD与OR运算符</h1><div class="hljs code-wrapper"><pre><code class="hljs">  AND与OR可以在WHERE子句中把两个多个条件结合起来  AND表示必须同时满足多个条件，相当于javascript中的&amp;&amp;运算符  OR表示只要满足一个条件就可以，相当于javascript中的||运算符</code></pre></div><h1 id="SQL语句中的ORDER-BY子句"><a href="#SQL语句中的ORDER-BY子句" class="headerlink" title="SQL语句中的ORDER BY子句"></a>SQL语句中的ORDER BY子句</h1><div class="hljs code-wrapper"><pre><code class="hljs">  ORDER BY子句用于根据指定的列对结果集进行排序  ORDER BY子句默认按照升序记录进行排序  如果希望降序排列，可以使用DESC关键字     例如：select * from node_user order by id DESC;   ORDER BY子句多重排序：          例如先按照id字段降序排列，再按name升序排序：select * from node_user order by id DESC,name asc;</code></pre></div><h1 id="SQL语句中的count函数与as关键字"><a href="#SQL语句中的count函数与as关键字" class="headerlink" title="SQL语句中的count函数与as关键字"></a>SQL语句中的count函数与as关键字</h1><div class="hljs code-wrapper"><pre><code class="hljs">  count(*)函数用于返回查询结果总数居条数，语法格式：        SELECT COUNT(*) FROM 表名称  可以使用AS关键字来为列设置别名        例如：查询出来的列的名称设置别名 SELECT COUNT(*) AS total FROM node_user WHERE id&gt;2</code></pre></div><h1 id="在项目中操作数据库"><a href="#在项目中操作数据库" class="headerlink" title="在项目中操作数据库"></a>在项目中操作数据库</h1><div class="hljs code-wrapper"><pre><code class="hljs">  1、安装操作数据库的第三方模块mysql  2、通过mysql模块连接到mysql数据库          //建立与mysql数据库的连接关系            const db=mysql.createPool(&#123;              host:&#39;127.0.0.1&#39;,             //数据库地址              port:&#39;3306&#39;,                   //端口              user:&#39;root&#39;,                   //登录数据账号              password:&#39;123456&#39;,             //密码              database:&#39;node_test&#39;           //数据库            &#125;)  3、通过mysql模块执行SQL语句           //查询数据库            db.query(&#39;SELECT * FROM node_user&#39;,(err, results)=&gt;&#123;              if(err) return console.log(&#39;数据库连接失败:&#39;,err.message)              //打印出结果              console.log(results)            &#125;)            //向user表中插入的数据            const user =&#123;id:5,name:&#39;hzx&#39;,password:897&#125;            //将执行的SQL语句，？表示占位符            const sqlStr=&#39;insert into node_user (id,name,password) values(?,?,?) &#39;            //插入数据            db.query(sqlStr,[user.id,user.name,user.password],(err,results)=&gt;&#123;              if(err) return console.log(&#39;数据库连接失败:&#39;,err.message)              //打印插入的结果              if(results.affectedRows ===1)&#123;console.log(&#39;插入成功&#39;)&#125;            &#125;)      注意：插入数据时，插入字段更多时，可以使用该SQL语句：insert into 表名 set ？            修改数据时，修改字段很多时，可以使用update 表名 set ? where id=?</code></pre></div><h1 id="web开发模式"><a href="#web开发模式" class="headerlink" title="web开发模式"></a>web开发模式</h1><div class="hljs code-wrapper"><pre><code class="hljs">     1、基于服务端渲染的开发模式             优点：前端耗时少，因为服务器端负责动态生成html的内容，浏览器只需要渲染页面即可，尤其是移动端，更省电                  有利于SEO，因为服务器端响应的是完整的html内容，所以爬虫更容易获取信息，更有利于SEO             缺点：                   占用服务器端资源                   不利于的前后端分离，开发效率低     2、前后端分离的开发模式             概念：前后端分离的开发模式，依赖于AJAX技术的广泛应用。简而言之，                    就是后端只负责API接口、前端使用AJAX调用接口的开发模式             优点：                  开发体验好                  用户体验好                  减轻了服务器端压力            缺点：                  不利于SEO</code></pre></div><h1 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h1><div class="hljs code-wrapper"><pre><code class="hljs">      身份认证又称身份验证、鉴权是指通过一定手段，完成对用户身份的确认。      在web开发中，也涉及用户身份的验证，例如各大网站的手机号验证码登录、邮箱登录、二维码登录等。          1、服务器渲染开发模式推荐使用session认证机制     2、前后端分离推荐使用JWT认证机制</code></pre></div><h1 id="session认证机制"><a href="#session认证机制" class="headerlink" title="session认证机制"></a>session认证机制</h1><div class="hljs code-wrapper"><pre><code class="hljs">     http协议的无状态性：指的是客户端的每次http请求都是独立的，连接多个请求没有直接的关系，服务器不会主动保留http请求的状态     突破http无状态性：cookie</code></pre></div><h1 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h1><div class="hljs code-wrapper"><pre><code class="hljs">    cookie是存储在用户浏览器中一段不超过4kb的字符串，他是由一个名称、一个值和其他几个用于控制cookie有效期、安全性、使用范围组成    不同域名的cookie是独立存在的，每当客户端发起请求时，会自动把当前域名下所有未过期的cookie一同发送给服务器    cookie特性：          1、自动发送          2、域名独立          3、过期时限          4、4kb限制</code></pre></div><h1 id="cookie在身份认证的作用"><a href="#cookie在身份认证的作用" class="headerlink" title="cookie在身份认证的作用"></a>cookie在身份认证的作用</h1><div class="hljs code-wrapper"><pre><code class="hljs">   客户端在第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的cookie，客户端会将cookie保存在浏览器中   随后，当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的cookie、通过请求头形式发送给浏览器，服务器即可验证客户端身份。      cookie不具有安全性，cookie是储存在浏览器中，而浏览器提供了cookie的读写API，因此cookie极易被伪造，不要存放用户隐私及密码</code></pre></div><h1 id="session工作原理"><a href="#session工作原理" class="headerlink" title="session工作原理"></a>session工作原理</h1><div class="hljs code-wrapper"><pre><code class="hljs">     .....</code></pre></div><h1 id="在express中使用session认证"><a href="#在express中使用session认证" class="headerlink" title="在express中使用session认证"></a>在express中使用session认证</h1><div class="hljs code-wrapper"><pre><code class="hljs">          // TODO_01：请配置 Session 中间件          const session=require(&#39;express-session&#39;)          app.use(session(&#123;            secret:&#39;hezhixing&#39;,            resave:false,            saveUninitialized:true,          &#125;))</code></pre></div><h1 id="JWT认证机制"><a href="#JWT认证机制" class="headerlink" title="JWT认证机制"></a>JWT认证机制</h1><div class="hljs code-wrapper"><pre><code class="hljs">     session认证机制需要配合cookie才能使用，由于cookie不支持跨域访问，所以当涉及到前端跨域请求后后端连接     接口的时候，需要做很多额外的配置，才能实现seesion认证     注意：当前端请求后端接口不存在跨域问题时，推荐使用session认证机制           需要跨域请求后端接口时，推荐使用JWT认证机制         JWT(JSON web token)是目前最流行的跨域认证方案</code></pre></div><h1 id="JWT工作原理"><a href="#JWT工作原理" class="headerlink" title="JWT工作原理"></a>JWT工作原理</h1><div class="hljs code-wrapper"><pre><code class="hljs">     ....</code></pre></div><h1 id="JWT组成部分"><a href="#JWT组成部分" class="headerlink" title="JWT组成部分"></a>JWT组成部分</h1><div class="hljs code-wrapper"><pre><code class="hljs">   JWT通常由三部分组成，分别是Header头部、payload有效荷载、signature签名。三者采用英文“.”分割，格式：              Header.payload.signature  payload才是真正的用户信息，他是经过加密之后生成的字符串  header和signature是为了保证token安全</code></pre></div><h1 id="JWT使用方式"><a href="#JWT使用方式" class="headerlink" title="JWT使用方式"></a>JWT使用方式</h1><div class="hljs code-wrapper"><pre><code class="hljs">  客户端收到服务器返回的JWT之后，通常会将它储存在localStorage或sessionStorage中  此后，客户端每次与服务器端通信都要带上这个JWT的字符串，从而进行身份认证。  推荐的做法是将JWT放在http请求头的Authorization字段中，格式：        Authorization：Bearer &lt;token&gt;</code></pre></div><h1 id="生成token的步骤"><a href="#生成token的步骤" class="headerlink" title="生成token的步骤"></a>生成token的步骤</h1><div class="hljs code-wrapper"><pre><code class="hljs">   1、使用npm i express-jwt jsonwebtoken命令下载第三方包   2、引入这两个包            const jsonwebtoken=require(&#39;jsonwebtoken&#39;)            const expressJWT=require(&#39;express-jwt&#39;)   3、定义 secret 密钥，建议将密钥命名为 secretKey                    const secretKey=&#39;hezhixing No1&#39;   4、在登录成功之后，调用jsonwebtoken.sign() 方法生成 JWT 字符串。并通过 token 属性发送给客户端        //该方法会传递三个参数，参数1：用户信息对象，参数2：加密的密钥，参数3：配置对象，可以配置token的有效期        //记住千万不要把密码加密到token中        const jwtStr=jsonwebtoken.sign(&#123;username:userinfo.username&#125;,secretKey,&#123;expiresIn:&#39;30s&#39;&#125;)            res.send(&#123;              status: 200,              message: &#39;登录成功！&#39;,              token: jwtStr // 要发送给客户端的 token 字符串            &#125;)    5、注册将 JWT 字符串解析还原成 JSON 对象的中间件            //配置成功了express-jwt中间件，就可以将解析出来的用户信息，挂载到req.user(req.auth)上            app.use(expressJWT(&#123;algorithms:[&#39;HS256&#39;],secret:secretKey&#125;).unless(&#123;path:[/^\/api\//]&#125;))    6、使用 req.user 获取用户信息，并使用 data 属性将用户信息发送给客户端                  console.log(req.user)                  res.send(&#123;                    status: 200,                    message: &#39;获取用户信息成功！&#39;,                    data: req.user // 要发送给客户端的用户信息                  &#125;)    7、使用全局错误处理中间件，捕获解析 JWT 失败后产生的错误            app.use((err,req,res,next)=&gt;&#123;              //错误级别的中间件              //这次错误是由token解析失败导致的              if(err.name===&#39;UnauthorizedError&#39;)&#123;                return res.send(&#123;                  status:0,                  msg:&#39;无效的token&#39;                &#125;)              &#125;</code></pre></div><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><div class="hljs code-wrapper"><pre><code class="hljs"> 此文档是学习黑马程序员B站视频记录。学习请搜索黑马程序员node课程</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node基础 </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2脚手架</title>
      <link href="/2022/05/12/vue/vue2%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2022/05/12/vue/vue2%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="关于不同版本的vue："><a href="#关于不同版本的vue：" class="headerlink" title="关于不同版本的vue："></a>关于不同版本的vue：</h2><div class="hljs code-wrapper"><pre><code class="hljs">1、vue.js与vue.runtime.xxx.js的区别： （1）vue.js是完整版的vue，包含：vue核心+模板解析器 （2）vue.runtime.xx.js,是运行版的js，只包含核心功能，没有模板解析器2、因为vue.runtime.xxx.js没有模板解析器，所以不能使用templata配置项，需要使用rander函数接收到的createElement函数去指定具体内容3、组件中的template有专门的模板解析器，只需在main.js中创建vue实例需要使用hender函数</code></pre></div><h2 id="vue-config-js配置："><a href="#vue-config-js配置：" class="headerlink" title="vue.config.js配置："></a>vue.config.js配置：</h2><div class="hljs code-wrapper"><pre><code class="hljs">&gt;使用vue inspect &gt;output.js可以查看vue脚手架的默认配置&gt;使用vue.config.js配置，详情请见官网</code></pre></div><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、被用来给元素或者子组件注册引用信息（id的替代者） 2、应用在html标签上获取真实DOM元素，应用在组件标签是组件实例对象（vc） 3、使用方式：  打标识：&lt;h1 ref=&quot;xxxx&quot;&gt;&lt;/h1&gt;或者 &lt;School ref=&quot;sch&quot;&gt;&lt;/School&gt;  获取：this.$refs.xxx</code></pre></div><h2 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h2><div class="hljs code-wrapper"><pre><code class="hljs">功能让组件接收外部传来的数据（1）传递数据：       &lt;demo name=&quot;xxx&quot;/&gt;（2）接收数据：       第一种方式（只接收）：       props：[&#39;name&#39;]       第二种方式限制类型：       props:&#123;         name:String       &#125;       第三种方式，限制类型+默认值设定+必要性限定;       props:&#123;         name:&#123;           type:String,        //类型           required:true,      //必要性           default:&#39;hezhixing&#39; //默认值         &#125;       &#125;备注：props是只读，vue底层会检测你对props的修改，如果进行了修改，就会发出警告    若业务需求需要改，那么请复制props的内容到data中一份，然后修改data</code></pre></div><h2 id="mixin混入"><a href="#mixin混入" class="headerlink" title="mixin混入"></a>mixin混入</h2><div class="hljs code-wrapper"><pre><code class="hljs">功能：可以把多个组件共用配置对象提出成一个混入对象使用方式：  第一步定义混入，例:    &#123;      data()&#123;.....&#125;      methods:&#123;....&#125;      .....    &#125;  第二步使用混入，例如：     （1）全局混入：Vue.mixin(xxx);     （2）局部混入：mixin:[&#39;xxx&#39;];</code></pre></div><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><div class="hljs code-wrapper"><pre><code class="hljs">功能：用于增强Vue本质：包含一个install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据定义插件：install(Vue)&#123;//全局过滤器Vue.filter(&#39;mySlice&#39;,function(value)&#123;  return value.slice(0,5)&#125;)//定义混入Vue.mixin(&#123;  data()&#123;    return&#123;      x:100    &#125;  &#125;&#125;)//自定义指令Vue.directive(&#39;fbind&#39;,&#123;    //指令与元素绑定时调用    bind(element,binding)&#123;      console.log(&quot;指令与元素成功绑定&quot;);      element.value=binding.value;    &#125;,    //指令所在元素被插入时调用    inserted(element,binding)&#123;      console.log(&quot;指令所在元素被成功插入&quot;);      element.focus();    &#125;,    //指令所在模板被重新解析时被调用    update(element,binding)&#123;      console.log(&quot;指令所在模板被重新解析&quot;);      element.value=binding.value;      element.focus();    &#125;, &#125;)//定义原型方法Vue.prototype.demo=()=&gt;&#123;alert(&quot;你好&quot;)&#125;&#125;使用插件：Vue.use()</code></pre></div><h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 作用：让样式在局部生效，防止冲突 写法：&lt;style scoped&gt;</code></pre></div><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、组件化编码流程：    （1）拆分静态组件：组件要按功能点拆分，命名不要与html冲突    （2）实现动态组件：考虑好数据存放的位置，数据是一个组件在用，还是一些组件在用：            1）一个组件在用：放到组件自身即可            2）一些组件在用：放到他们共同的父组件身上（状态提升）    （3）实现交互：从绑定事件开始。 2、props适用于：    （1）.父组件===&gt;子组件通信    （2）.子组件===&gt;父组件通信（要求先给子一个函数） 3、使用v-model要切记：v-model绑定的值不能是props传递过来的值，因为props是不可以修改的 4、props传过来的若是对象类型的值，修改对象中的属性Vue不会报错，但不推荐这么做</code></pre></div><h2 id="浏览器本地缓存"><a href="#浏览器本地缓存" class="headerlink" title="浏览器本地缓存"></a>浏览器本地缓存</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、存储内容大小一般是5M左右（不同浏览器不同） 2、浏览器端通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制 3、相关API：     1.xxxxxStorage.setItem(&#39;msg&#39;,&#39;hello!&#39;)        该方法接收一个键和值作为参数，会把键值对添加到存储中，如果键名已存在，会更新对应的值     2.xxxxxxStorage.getItem(&#39;person&#39;);        该方法会接收一个键名作为参数，返回其对应的值     3.xxxxxxxStorage.removeItem(&#39;msg&#39;);        该方法会接收一个键名作为参数，删除其对应的值     4.xxxxxxStorage.clear()        该方法会清空存储中的所有数据 4、备注：      1.SessionStorage存储内容会随着浏览器的关闭而消失      2.LocalStorage存储内容不会会随着浏览器的关闭而消失，而需要手动清除      3.xxxxxxStorage.getItem(&#39;person&#39;)如果找不到参数，那么getter返回值为null      4.JSON.parse(null)结果为空</code></pre></div><h2 id="组件自定义事件"><a href="#组件自定义事件" class="headerlink" title="组件自定义事件"></a>组件自定义事件</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、一种组件之间的通信方式，适用于子===&gt;父组件 2、使用场景：A是父组件，B是子组件，B想给A传递数据，那么就要在A中为B绑定自定义事件（事件的回调在A中） 3、绑定自定义事件：        1.第一种方式：在父组件中：          &lt;Student v-on:hezhixing.once=&quot;getStudetName&quot;&gt;&lt;/Student&gt;        2.第二种方式：在父组件中          &lt;Student ref=&#39;student&#39;&gt;&lt;/Student&gt;            mounted() &#123;               this.$refs.student.$on(&#39;hezhixing&#39;,(name)=&gt;&#123;                   console.log(&#39;App收到了学生名&#39;,name);                   this.studentName=name               &#125;);          &#125;, 4、触发自定义事件：this.$emit(&#39;hezhixing&#39;,this.name) //绑定一个自定义事件 5、解绑自定义事件： this.$off(&#39;hezhixing&#39;)            //解绑一个事件 6、组件上也可以绑定原生DOM事件，需要native修饰符 7、注意使用 this.$refs.student.$on(&#39;hezhixing&#39;,回调函数）时，回调要么配置在methods中，要么使用箭头函数，    否则this的指向会出现问题</code></pre></div><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、一种组件间通信方式，适用于任意组件间通信 2、安装全局事件总线：      new Vue(&#123;         el:&quot;#app&quot;,         render: h =&gt;h(App),         beforeCreate()&#123;         Vue.prototype.$bus=this   //安装全局事件总线        &#125;     &#125;) 3、使用事件总线：      1.接收数据：A组件想接收数据，则在A组件给$bus绑定自定义事件，事件的回调留在A组件自身             mounted() &#123;               this.bus.$on(&#39;hello&#39;,(name)=&gt;&#123;                 console.log(&#39;school&#39;,name)               &#125;)             &#125;,             beforeDestroy() &#123;               this.$bus.$off(&#39;hello&#39;)             &#125;,      2.提供数据：            this.$bus.$emit(&#39;hello&#39;,this.name)  4、最好在beforeDestroy钩子中，用$off去解绑当前组件用到的事件</code></pre></div><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、一种组件间通信的方式，适用于任意组件间通信  2、使用步骤：        1、安装pubsub：npm i pubsub-js        2、引入：import pubsub from &#39;pubsub-js        3、接收数据：A组件想要接收数据，则在A组件中订阅消息，订阅的回调留在A中            mounted() &#123;              pubsub.subscribe(&#39;hello&#39;,(msgName,data)=&gt;&#123;                console.log(&#39;有人发布了订阅消息，hello的回调执行了&#39;,data)  //消息订阅              &#125;)            &#125;,        4、提供数据：  pubsub.publish(&#39;hello&#39;,666)  //消息发布        5、最好在beforeDestroy钩子中，用 pubsub.unsubscribe(&#39;hello&#39;)取消消息订阅</code></pre></div><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、语法：this.$nextTick(回调函数）  2、作用：在下一次DOM更新结束后执行其指定的回调。  3、什么时候用：当改变数据后，要基于更新后新的DOM某些操作时，要在nextTick所指定的回调函数中执行</code></pre></div><h2 id="Vue封装的过渡与总结"><a href="#Vue封装的过渡与总结" class="headerlink" title="Vue封装的过渡与总结"></a>Vue封装的过渡与总结</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、作用：在插入、更新或者移出DOM是，在合适的时候为元素添加样式类名   ..........</code></pre></div><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><div class="hljs code-wrapper"><pre><code class="hljs">方法一：   在vue.config.js中配置：         devServer: &#123;            proxy: &#39;http://localhost:5000&#39;          &#125;,   说明：        1、优点：配置简单，请求资源时直接发送给前端（8080）即可        2、缺点：不能配置多个代理，不能灵活的控制请求是否走代理        3、工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求就会转发给服务器 方法二：    在vue.config.js中配置：  devServer: &#123;    proxy: &#123;     &#39;/api1&#39;: &#123;  //匹配所有以api1开头的路径       target: &#39;http://localhost:5000&#39;,   //代理目标路径       pathRewrite:&#123;&#39;^/api1&#39;:&#39;&#39;&#125;,   //重写路径       ws: true,                   //用于支持websocket,默认为真       changeOrigin: true         //用于控制请求头中host值，默认为真     &#125;,     &#39;/api2&#39;: &#123;       target: &#39;http://localhost:5001&#39;,       pathRewrite:&#123;&#39;^/api2&#39;:&#39;&#39;&#125;,   //重写路径       ws: true,                   //用于支持websocket,默认为真       changeOrigin: true         //用于控制请求头中host值，默认为真    &#125;   &#125; &#125;       说明：    1、优点：可以配置多个代理，且可以灵活的控制请求是否走代理    2、缺点：配置繁琐，请求时必须加前缀</code></pre></div><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、作用：让父组件可以向子组件的指定位置插入html结构，也是组件间通信的一种方式，适用于父组件与子组件通信 2、分类：默认插槽、具名插槽、作用域插槽 3、使用方式：       1.默认插槽：           父组件中： &lt;Category title=&quot;美食&quot;&gt;html结构&lt;/Category&gt;           子组件中：&lt;div class=&quot;category&quot;&gt;                    &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;                    &lt;!-- 定义一个插槽（等待填充），未填充就使用默认值  默认插槽--&gt;                    &lt;slot&gt;我是一个默认插槽，当组件未填充时，我就会出现&lt;/slot&gt;                    &lt;/div&gt;       2.具名插槽：           父组件中： &lt;Category title=&quot;电影&quot; &gt;                      &lt;video slot=&quot;center&quot; src=&quot;http://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4&quot; controls&gt;&lt;/video&gt;                       &lt;template v-slot:footer&gt;                          &lt;a href=&quot;https://www.biadu.com&quot;&gt;热门视频&lt;/a&gt;                          &lt;h4&gt;欢迎来观影&lt;/h4&gt;                       &lt;/template&gt;                     &lt;/Category&gt;           子组件中：                     &lt;slot name=&quot;center&quot;&gt;我是一个默认插槽，当组件未填充时，我就会出现1&lt;/slot&gt;                     &lt;slot name=&quot;footer&quot;&gt;我是一个默认插槽，当组件未填充时，我就会出现2&lt;/slot&gt;         3.作用域插槽              1.理解：数据在组件的自身，但根据数据的生成的结构需要组件的使用者来决定。              2.具体编码：                   父组件中： &lt;Category title=&quot;游戏&quot;&gt;                                &lt;template scope=&quot;&#123;games&#125;&quot;&gt;   //&#123;games&#125;解构赋值                               &lt;ul&gt;                                 &lt;li  v-for= &quot;(item,index) in games&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;                               &lt;/ul&gt;                               &lt;/template&gt;                            &lt;/Category&gt;                子组件中： &lt;div class=&quot;category&quot;&gt;                              &lt;h3&gt;&#123;&#123;title&#125;&#125;分类&lt;/h3&gt;                              &lt;slot :games=&quot;games&quot;&gt;我是默认内容&lt;/slot&gt;                          &lt;/div&gt;</code></pre></div><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><div class="hljs code-wrapper"><pre><code class="hljs">    Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。    如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。    一个简单的 store 模式就足够您所需了。但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，    Vuex 将会成为自然而然的选择。项目结构 ├── index.html ├── main.js ├── api │   └── ... # 抽取出API请求 ├── components │   ├── App.vue │   └── ... └── store    ├── index.js          # 我们组装模块并导出 store 的地方    ├── actions.js        # 根级别的 action    ├── mutations.js      # 根级别的 mutation    └── modules       ├── cart.js       # 购物车模块       └── products.js   # 产品模块</code></pre></div><h2 id="getters的使用"><a href="#getters的使用" class="headerlink" title="getters的使用"></a>getters的使用</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、概念：当state中的数据需要加工后再使用时，可以使用getters加工  2、在store.js中追加getters配置      const getters=&#123;         bigSum(state)&#123;           return state.sum*10         &#125;      &#125;    //创建store,并暴露      export default new Vuex.Store(&#123;         actions,         mutations,         state,         getters      &#125;);   3、组件中读取数据：$store.getters.bigSum</code></pre></div><h2 id="mapState、mapGetters、mapMutations与mapActions"><a href="#mapState、mapGetters、mapMutations与mapActions" class="headerlink" title="mapState、mapGetters、mapMutations与mapActions"></a>mapState、mapGetters、mapMutations与mapActions</h2><div class="hljs code-wrapper"><pre><code class="hljs">    使用前要使用解构赋值引入：import &#123;mapGetters, mapState&#125; from &#39;vuex&#39;mapState方法：   用于帮助我们映射state中的数据为计算属性         computed:&#123;         //借助mapState生成计算属性，从State中读取数据（对象写法）         // ...mapState(&#123;he:&#39;sum&#39;,xuexiao:&#39;school&#39;,xueke:&#39;subject&#39;&#125;),             //借助mapState生成计算属性，从State中读取数据（数组写法）        ...mapState([&#39;sum&#39;,&#39;school&#39;,&#39;subject&#39;]),        &#125;,mapGetters方法：用于我们映射getters中的数据为计算属性          computed:&#123;            ...mapGetters(&#123;bigSum:&#39;bigSum&#39;&#125;),          &#125;,mapMutations:用于帮助我们生成与mutations对话的方法，包含$store.commit(xxx)的函数mapMutations:用于帮助我们生成与mutations对话的方法，包含$store.dispatch(xxx)的函数      methods: &#123;  // add()&#123;  //   this.$store.commit(&#39;JIA&#39;,this.n)  // &#125;,  // cut()&#123;  //   this.$store.commit(&#39;JIAN&#39;,this.n)  // &#125;,   /* *************************** */   //借助mapMutations生成对应的方法，方法中会调用commit去联系mutations(对象写法)  ...mapMutations(&#123;add:&#39;JIA&#39;,cut:&#39;JIAN&#39;&#125;),  // fnFormatNumber()&#123;  //   this.$store.dispatch(&#39;ifadd&#39;,this.n);  // &#125;,  // define()&#123;  //     this.$store.dispatch(&#39;delay&#39;,this.n)  // &#125;  ...mapActions(&#123;fnFormatNumber:&#39;ifadd&#39;,define:&#39;delay&#39;&#125;) &#125;,</code></pre></div><h2 id="模块化-命名空间"><a href="#模块化-命名空间" class="headerlink" title="模块化+命名空间"></a>模块化+命名空间</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、目的：让代码更易维护，让多种数据分类更加明确   .......</code></pre></div><h2 id="路由（vue-router"><a href="#路由（vue-router" class="headerlink" title="路由（vue-router)"></a>路由（vue-router)</h2><div class="hljs code-wrapper"><pre><code class="hljs">  vue的一个插件库，专门用来实现SPA应用</code></pre></div><h2 id="SPA应用的理解"><a href="#SPA应用的理解" class="headerlink" title="SPA应用的理解"></a>SPA应用的理解</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1.单页面应用（single page web application)  2.整个页面只有一个完整的页面  3.点击页面中的导航链接不会刷新页面，只会做页面的局部更新  4.数据需要通过ajax请求</code></pre></div><h2 id="路由的理解"><a href="#路由的理解" class="headerlink" title="路由的理解"></a>路由的理解</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、什么是路由       1.一个路由就是一组映射关系（key-value）       2.key为路径，value可能是function或者component  2、路由的分类     1.后端路由         1)理解：value是function，用于处理客户端提交的请求         2）工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据     2.前端路由：         1）理解：value是component，用于展示页面信息         2）工作过程：当浏览器的路径改变时，对应的组件就会显示</code></pre></div><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、安装vue-router，命令：npm i vue-router@3(vue3默认版本为4）  2、应用插件：vue.use(VueRouter)  3、编写router配置项：    /* 该文件创建整个应用的路由器 */    import VueRouter from &#39;vue-router&#39;;    //引入组件    import About from &#39;../components/About&#39;;    import Home from &#39;../components/Home&#39;    //创建一个路由器,并暴露    export default new VueRouter(&#123;      routes:[        &#123;          path:&#39;/About&#39;,          component:About        &#125;,        &#123;          path:&#39;/Home&#39;,          component:Home        &#125;      ]    &#125;)   4、实现切换：        &lt;!-- vue中借助router-link实现路由的切换  --&gt;        &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/About&quot;&gt;About&lt;/router-link&gt;        &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/Home&quot;&gt;Home&lt;/router-link&gt;   5、指定展示位置：         &lt;!-- 指定组件中的呈现位置 --&gt;           &lt;router-view&gt;此处展示什么内容，根据用户点击&lt;/router-view&gt;</code></pre></div><h2 id="路由的几个注意点"><a href="#路由的几个注意点" class="headerlink" title="路由的几个注意点"></a>路由的几个注意点</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、路由组件通常存放在pages文件夹中，一般组件通常放在components文件夹中  2、通过切换，&quot;隐藏&quot;了路由组件，默认是被销毁的，需要的时候再去挂载  3、每个组件都有自己的$route属性，里面存放自己的路由信息  4、整个应用只有一个router，可以通过组件的$router属性获取到</code></pre></div><h2 id="嵌套（多级）路由"><a href="#嵌套（多级）路由" class="headerlink" title="嵌套（多级）路由"></a>嵌套（多级）路由</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、配置路由规则，使用children配置项：        /* 该文件创建整个应用的路由器 */        import VueRouter from &#39;vue-router&#39;;        //引入组件        import About from &#39;../pages/About&#39;;        import Home from &#39;../pages/Home&#39;;        import News from &#39;../pages/News&#39;;        import Message from &#39;../pages/Message&#39;        //创建一个路由器,并暴露        export default new VueRouter(&#123;          routes:[            &#123;              path:&#39;/About&#39;,              component:About            &#125;,            //一级路由             &#123;              path:&#39;/Home&#39;,              component:Home,              children:[   //通过children配置子级路由                &#123;                  path:&#39;news&#39;,   //此处一定不要写/news，因为他会默认为你添加一个/                  component:News                &#125;,                &#123;                  path:&#39;message&#39;,                  component:Message                &#125;              ]            &#125;          ]        &#125;)    2、跳转的路径要写完整的路径：    &lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/Home/message&quot;&gt;Message&lt;/router-link&gt;</code></pre></div><h2 id="路由的参数传递"><a href="#路由的参数传递" class="headerlink" title="路由的参数传递"></a>路由的参数传递</h2><div class="hljs code-wrapper"><pre><code class="hljs">1、传递参数：      &lt;!-- 跳转路由并携带query参数，to的字符串写法 --&gt;    &lt;router-link :to=&quot;`/Home/message/detail?id=$&#123;item.id&#125;&amp;title=$&#123;item.title&#125;`&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/router-link&gt;      &lt;!-- 跳转路由并携带query参数，to的对象的写法 --&gt;    &lt;router-link :to=&quot;&#123;      path:&#39;/Home/message/detail&#39;,      query:&#123;        id:item.id,        title:item.title      &#125;    &#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;  &lt;/li&gt;2、接收参数：    &lt;ul&gt;      &lt;li&gt;消息编号:&#123;&#123;$route.query.id&#125;&#125;&lt;/li&gt;      &lt;li&gt;消息标题:&#123;&#123;$route.query.title&#125;&#125;&lt;/li&gt;    &lt;/ul&gt;</code></pre></div><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1、命名路由的作用：简化路由的跳转 2、如何使用：      在路由配置中添加name属性       routes:[          &#123;            name:&#39;guanyu&#39;,            path:&#39;/About&#39;,            component:About          &#125;,    直接使用名字跳转： &lt;router-link :to=&quot;&#123;name:&#39;guanyu&#39;&#125;&quot;&gt;About&lt;/router-link&gt;</code></pre></div><h2 id="路由中的params参数"><a href="#路由中的params参数" class="headerlink" title="路由中的params参数"></a>路由中的params参数</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、配置路由，声明接收params参数   &#123;      path:&#39;message&#39;,      component:Message,      children:[        &#123;          name:&#39;xiangqing&#39;,          path:&#39;detail/:id/:title&#39;,  //使用占位符声明接收params参数          component:Detail        &#125;      ]    &#125;  2、传递参数：       &lt;li v-for=&quot;item in messageList&quot; :key=&quot;item.id&quot;&gt;        // 跳转路由并携带params参数，to的字符串写法        &lt;router-link :to=&quot;`/Home/message/detail/$&#123;item.id&#125;/$&#123;item.title&#125;`&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;                //跳转路由并携带params参数，to的对象的写法        &lt;router-link :to=&quot;&#123;          name:&#39;xiangqing&#39;,          params:&#123;            id:item.id,            title:item.title          &#125;        &#125;&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;/router-link&gt;&amp;nbsp;&amp;nbsp;      &lt;/li&gt;  </code></pre></div><h2 id="路由的props配置"><a href="#路由的props配置" class="headerlink" title="路由的props配置"></a>路由的props配置</h2><div class="hljs code-wrapper"><pre><code class="hljs">  作用：让路由组件更加方便的收到参数：      &#123;      path:&#39;message&#39;,      component:Message,      children:[        &#123;          name:&#39;xiangqing&#39;,          path:&#39;detail/:id/:title&#39;,  //使用占位符声明接收params参数          component:Detail,          //props的第一种写法，值为对象,该对象中的所有key-value都会以props的形式传递给Detail组件          // props:&#123;a:100,b:&#39;hello&#39;&#125;          //props的第二种写法，值为布尔值,若布尔值为真，就会把该路由组件收到的所有params参数，以props以props参数的形式传递给Detail组件          // props:true,          //props的第三种写法，值为函数          props($route)&#123;            return &#123; id:$route.query.id,title:$route.query.title&#125;          &#125;        &#125;      ]    &#125;</code></pre></div><h2 id="的replace"><a href="#的replace" class="headerlink" title="的replace"></a><router-link>的replace</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、作用：控制路由跳转时操作浏览器历史记录的模式  2、浏览器的历史记录有两种写入方式：分别为push和replace，push时追加浏览器历史记录     replace是替换当前记录。路由跳转默认为push  3、如何开启：向标签中添加replace属性  &lt;router-link replace:to=&quot;&#123;name:&#39;guanyu&#39;&#125;&quot;&gt;About&lt;/router-link&gt;</code></pre></div><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、作用：不借助&lt;router-link&gt;实现路由跳转，让路由更加灵活  2、具体编码：    四个API：this.$router.push()、this.$router.replace()、this.$router.back()、 this.$router.go(2)    pushShow(item)&#123;    this.$router.push(&#123;      name:&#39;xiangqing&#39;,      params:&#123;        id:item.id,        title:item.title      &#125;    &#125;)  &#125;,  replaceShow(item)&#123;    this.$router.replace(&#123;      name:&#39;xiangqing&#39;,      params:&#123;        id:item.id,        title:item.title      &#125;    &#125;)  &#125; this.$router.back();  this.$router.go(2);</code></pre></div><h2 id="缓存路由组件"><a href="#缓存路由组件" class="headerlink" title="缓存路由组件"></a>缓存路由组件</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、作用：不展示的路由组件保持挂载，不销毁  2、具体编码：         &lt;!-- include属性是添加保存缓存的组件名 --&gt;          &lt;keep-alive include=&quot;News&quot;&gt;             &lt;router-view&gt;&lt;/router-view&gt;          &lt;/keep-alive&gt;         缓存多个         &lt;keep-alive include=&quot;[News,&#39;Message&#39;]&quot;&gt;             &lt;router-view&gt;&lt;/router-view&gt;          &lt;/keep-alive&gt;</code></pre></div><h2 id="两个新的生命周期钩子"><a href="#两个新的生命周期钩子" class="headerlink" title="两个新的生命周期钩子"></a>两个新的生命周期钩子</h2><div class="hljs code-wrapper"><pre><code class="hljs">  1、作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态  2、具体名字：      1.actived：路由组件被激活时触发      2.deactived：路由组件失活时触发</code></pre></div><h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><div class="hljs code-wrapper"><pre><code class="hljs"> 1.作用：对路由进行权限控制 2.分类：全局守卫，独享守卫、组件内守卫 3全局守卫：      //指定每一次路由切换调用函数，在初始化的时候被调用、每次路由切换之前被调用（全局前置路由守卫）      router.beforeEach((to,from,next)=&gt;&#123;        console.log(&#39;前置路由守卫&#39;,to,from);        //放行        if(to.meta.isAuth)&#123;  //控制是否需要权限          if(localStorage.getItem(&#39;school&#39;)===&#39;成都大学1&#39;)&#123;            next()          &#125;else&#123;            alert(&#39;学校名不对，无权查看&#39;)          &#125;        &#125;else&#123;          next()        &#125;      &#125;)      ////指定每一次路由切换调用函数，在初始化的时候被调用、每次路由切换之后被调用（全局后置路由守卫）      router.afterEach((to,from)=&gt;&#123;        console.log(&#39;后置路由守卫&#39;,to,from);        document.title=to.meta.title ||&#39;vue-test&#39;      &#125;)  4、独享路由守卫：        beforeEnter:(to,from,next)=&gt;&#123; //独享路由守卫          console.log(&#39;前置路由守卫&#39;,to,from);          //放行          if(to.meta.isAuth)&#123;  //控制是否需要权限            if(localStorage.getItem(&#39;school&#39;)===&#39;成都大学1&#39;)&#123;              next()            &#125;else&#123;              alert(&#39;学校名不对，无权查看&#39;)            &#125;          &#125;else&#123;            next()          &#125;      &#125;  5、组件内守卫：      //通过路由规则，进入该组件被调用      beforeRouteEnter (to, from, next) &#123;        // ...        console.log(&#39;APP---beforerouterenter&#39;);        //进入        next();        document.title=to.meta.title ||&#39;vue-test&#39;      &#125;,        //通过路由规则，离开该组件被调用      beforeRouteLeave (to, from, next) &#123;        // ...        next();              &#125;</code></pre></div><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript数据结构-链表</title>
      <link href="/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript数据结构-链表</title>
      <link href="/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"/>
      <url>/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript数据结构-队列</title>
      <link href="/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/* 封装优先级队列 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PriorityQueue</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//保存元素和优先级</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">QueueElement</span>(<span class="hljs-params">element,priority</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>=element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">priority</span>=priority;<br>    &#125;<br>    <span class="hljs-comment">//封装属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>=[];<br>    <span class="hljs-comment">//封装方法</span><br>    <span class="hljs-comment">//实现插入方法</span><br>    <span class="hljs-title class_">PriorityQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">enqueue</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">element,priority</span>)&#123;<br>        <span class="hljs-comment">// 1、创建QueueElement对象</span><br>        <span class="hljs-keyword">const</span> queueElement=<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueElement</span>(element,priority);<br>        <span class="hljs-comment">//2、判断队列是否为空</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>==<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-comment">//直接将实例化的元素与优先级对象push进来</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(queueElement)<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//3、for循环遍历比较队列中已有元素的优先级 </span><br>            <span class="hljs-keyword">var</span> added=<span class="hljs-literal">false</span>; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i].<span class="hljs-property">priority</span>&gt;queueElement.<span class="hljs-property">priority</span>)&#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(i,<span class="hljs-number">0</span>,queueElement);<br>                    added=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!added)&#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(queueElement)<br>            &#125;<br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">//toString</span><br>    <span class="hljs-title class_">PriorityQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> resultString=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;i++)&#123;<br>             resultString +=<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i]+<span class="hljs-string">&quot;&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> resultString<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//实例化类</span><br><span class="hljs-keyword">var</span> priorityQueue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>();<br><br><span class="hljs-comment">//向其添加元素</span><br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;何治兴&quot;</span>,<span class="hljs-number">153</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;李玉成&quot;</span>,<span class="hljs-number">323</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;李阳&quot;</span>,<span class="hljs-number">223</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">310</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(priorityQueue)<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript数据结构-链表</title>
      <link href="/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/* 封装优先级队列 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PriorityQueue</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//保存元素和优先级</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">QueueElement</span>(<span class="hljs-params">element,priority</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>=element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">priority</span>=priority;<br>    &#125;<br>    <span class="hljs-comment">//封装属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>=[];<br>    <span class="hljs-comment">//封装方法</span><br>    <span class="hljs-comment">//实现插入方法</span><br>    <span class="hljs-title class_">PriorityQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">enqueue</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">element,priority</span>)&#123;<br>        <span class="hljs-comment">// 1、创建QueueElement对象</span><br>        <span class="hljs-keyword">const</span> queueElement=<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueElement</span>(element,priority);<br>        <span class="hljs-comment">//2、判断队列是否为空</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>==<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-comment">//直接将实例化的元素与优先级对象push进来</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(queueElement)<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//3、for循环遍历比较队列中已有元素的优先级 </span><br>            <span class="hljs-keyword">var</span> added=<span class="hljs-literal">false</span>; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i].<span class="hljs-property">priority</span>&gt;queueElement.<span class="hljs-property">priority</span>)&#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(i,<span class="hljs-number">0</span>,queueElement);<br>                    added=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!added)&#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(queueElement)<br>            &#125;<br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">//toString</span><br>    <span class="hljs-title class_">PriorityQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> resultString=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;i++)&#123;<br>             resultString +=<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i]+<span class="hljs-string">&quot;&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> resultString<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//实例化类</span><br><span class="hljs-keyword">var</span> priorityQueue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>();<br><br><span class="hljs-comment">//向其添加元素</span><br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;何治兴&quot;</span>,<span class="hljs-number">153</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;李玉成&quot;</span>,<span class="hljs-number">323</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;李阳&quot;</span>,<span class="hljs-number">223</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">310</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(priorityQueue)<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript</title>
      <link href="/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">/* 封装优先级队列 */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">PriorityQueue</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//保存元素和优先级</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">QueueElement</span>(<span class="hljs-params">element,priority</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">element</span>=element;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">priority</span>=priority;<br>    &#125;<br>    <span class="hljs-comment">//封装属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>=[];<br>    <span class="hljs-comment">//封装方法</span><br>    <span class="hljs-comment">//实现插入方法</span><br>    <span class="hljs-title class_">PriorityQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">enqueue</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">element,priority</span>)&#123;<br>        <span class="hljs-comment">// 1、创建QueueElement对象</span><br>        <span class="hljs-keyword">const</span> queueElement=<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueElement</span>(element,priority);<br>        <span class="hljs-comment">//2、判断队列是否为空</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>==<span class="hljs-number">0</span>)&#123;<br>           <span class="hljs-comment">//直接将实例化的元素与优先级对象push进来</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(queueElement)<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//3、for循环遍历比较队列中已有元素的优先级 </span><br>            <span class="hljs-keyword">var</span> added=<span class="hljs-literal">false</span>; <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i].<span class="hljs-property">priority</span>&gt;queueElement.<span class="hljs-property">priority</span>)&#123;<br>                    <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">splice</span>(i,<span class="hljs-number">0</span>,queueElement);<br>                    added=<span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;  <br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!added)&#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-title function_">push</span>(queueElement)<br>            &#125;<br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">//toString</span><br>    <span class="hljs-title class_">PriorityQueue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> resultString=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>.<span class="hljs-property">length</span>;i++)&#123;<br>             resultString +=<span class="hljs-variable language_">this</span>.<span class="hljs-property">items</span>[i]+<span class="hljs-string">&quot;&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> resultString<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//实例化类</span><br><span class="hljs-keyword">var</span> priorityQueue=<span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>();<br><br><span class="hljs-comment">//向其添加元素</span><br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;何治兴&quot;</span>,<span class="hljs-number">153</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;李玉成&quot;</span>,<span class="hljs-number">323</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;李阳&quot;</span>,<span class="hljs-number">223</span>);<br>priorityQueue.<span class="hljs-title function_">enqueue</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">310</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(priorityQueue)<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2基础知识</title>
      <link href="/2022/05/11/vue/vue2%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/05/11/vue/vue2%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="初始vue"><a href="#初始vue" class="headerlink" title="初始vue"></a>初始vue</h1><div class="hljs code-wrapper"><pre><code class="hljs">  -一个容器只能对应一个实例，一一对应的关系 -想让vue工作，就要实例化vue，且要传入一个配置对象，即挂载点 -root容器中的代码依旧符合html规范，只不过混入了一些特殊的vue语法 -root容器中的代码被称为【vue】模板 -真实的开发环境是会配合这组件一起使用 -&#123;&#123;xxxx&#125;中要写js表达式，xxx会自动读取更新# 模板指令      #插值语法            &#123;&#123;&#125;&#125;,通常使用在标签体中，即两个标签空格中  #指令语法          通常用于解析标签，（包括标签属性，标签体的内容，给标签绑定事件）          例如：v-bind:href=&quot;xxxx&quot;,xxx同时也是js表达式，简写式为 :href=&quot;xxxx&quot;,加了：就代表寻找表达式</code></pre></div><h1 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h1><div class="hljs code-wrapper"><pre><code class="hljs">   v-bind是单向绑定，将数据从data绑定到页面标签属性   v-model是双向绑定，将数据双向绑定。   v-model只能用于表单类元素中（输入类      v-bind简写为   :value=&quot;&quot;   ,v-model:value=&quot;&quot;可以简写为v-model=&quot;&quot;</code></pre></div><h1 id="el与data的两种写法"><a href="#el与data的两种写法" class="headerlink" title="el与data的两种写法"></a>el与data的两种写法</h1><div class="hljs code-wrapper"><pre><code class="hljs">#el写法   第一种：   new Vue(&#123;        el:&quot;#root&quot;        data:&#123;           name:&quot;何治兴&quot;        &#125;    &#125;)   第二种：       const v=new Vue(&#123;        data:&#123;           name:&quot;何治兴&quot;        &#125;    &#125;)    v.$mount(&quot;#root&quot;);//mount有挂载的意思</code></pre></div><p>   #data写法,用组件时，要函数式<br>       第一种对象式：<br>         new Vue({<br>            el:”#root”<br>            data:{<br>               name:”何治兴”<br>            }<br>        })<br>       第二种函数式：不能使用箭头函数，如果使用箭头函数，this就不是vue实例<br>        new Vue({<br>            el:”#root”<br>            data:function(){<br>              return{<br>                 name:”何治兴”<br>              }<br>            }<br>        })</p><h1 id="理解MVVM"><a href="#理解MVVM" class="headerlink" title="理解MVVM"></a>理解MVVM</h1><p>  #MVVM<br>    M为模型（对应data中的数据），V代表VIEW（页面模板），VM为视图模型(代表vue实例对象)</p><div class="hljs code-wrapper"><pre><code class="hljs">data数据中的属性，最后都出现在了vm身上vm身上的属性及vue原型上的所有属性，在vue模板上都可以直接使用。 可以把vm（vue实例）理解为逻辑层，data理解为数据层，v理解为视图层</code></pre></div><h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h1><div class="hljs code-wrapper"><pre><code class="hljs">使用Object.defineProperty()添加的属性不能被枚举（遍历），删除，修改Object.defineProperty()方法会传递三个参数，第一个参数是需要增加属性的对象，第二个参数是属性名，三个参数是自定义对象&#123;value：//属性的值          enumerable：//是否可遍历          writable：//是否可修改          configurable：//是否可修改          get（）&#123;&#125;     //getter          set（)&#123;&#125;      //setter          &#125;</code></pre></div><h1 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h1><div class="hljs code-wrapper"><pre><code class="hljs">通过一个对象代理另外一个对象数据的读写</code></pre></div><h1 id="vue中的数据代理"><a href="#vue中的数据代理" class="headerlink" title="vue中的数据代理"></a>vue中的数据代理</h1><div class="hljs code-wrapper"><pre><code class="hljs">  -创建好一个vue实例之后，vm实例将会去获取data数据，将其保存在_data中，为了书写简单    vue就做了数据代理，通过vm对象来代理data对象属性的操作     -基本原理：通过Object.defineProperty()方法将data对象中的使用属性添加到vm上，            为每一个添加到vm上的属性，都指定一个getter和setter            在getter和setter内部去操作data对应属性</code></pre></div><h1 id="事件的使用"><a href="#事件的使用" class="headerlink" title="事件的使用"></a>事件的使用</h1><div class="hljs code-wrapper"><pre><code class="hljs">  1、使用v-on：xxx或者@xxx来绑定事件，其中xxx是事件名，如@click  2、事件的回调需要配置到methods对象中，最终会在vm上  3、methods中配置的函数，不要用箭头函数，否则this就不是指向vm  4、methods中配置的函数，都是被vue管理的函数，this的指向就是vm或者组件化对象  5、@click=&quot;demo&quot;与@click=&quot;demo($event)&quot;效果一致，后者可以传参</code></pre></div><h1 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h1><div class="hljs code-wrapper"><pre><code class="hljs">   用法@click.xxx=&quot;&quot;,xxx就是修饰符 1、prevent:阻止默认事件，比如阻止超链接的跳转 ，@click.prevent=&quot;&quot;,     在js基础中的DOM 操作是e.preventDefault() 2、stop:阻止冒泡，@click.stop=&quot;&quot;（在外层添加）     在js基础中，捕获是从外向内，冒泡是从内向外，并且是先不捕获，后冒泡 3、once:只触发一次 4、capture：使用事件的捕获模式，就是说先将捕获的事件处理，不会按照冒泡顺序处理 5、self：只有是当前的DOM元素才会触发，比如在外层添加这个修饰符，那么点击里面这个，不会触发外面这个事件 6、passive：将事件的默认行为立即执行，不会等待回调函数执行完毕</code></pre></div><h1 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h1><div class="hljs code-wrapper"><pre><code class="hljs">  -键盘事件有keyup,keydown,keypress  -键盘事件的属性和方法keyCode该属性包含键盘中对应键位的键值                  charCode该属性包含键盘中对应键位的 Unicode 编码，仅 DOM 支持                  target发生事件的节点（包含元素），仅 DOM 支持                  srcElement发生事件的元素，仅 IE 支持                  shiftKey是否按下 Shift 键，如果按下返回 true，否则为false                  ctrlKey是否按下 Ctrl 键，如果按下返回 true，否则为false                  altKey是否按下 Alt 键，如果按下返回 true，否则为false                  metaKey是否按下 Mtea 键，如果按下返回 true，否则为false，仅 DOM 支持  -键盘别名        回车enter        上下左右：up,down,left,right        空格：space        换行：tab        注意有的键盘别名在不同键盘事件使用方法不同，注意查看文档</code></pre></div><h1 id="事件总结"><a href="#事件总结" class="headerlink" title="事件总结"></a>事件总结</h1><div class="hljs code-wrapper"><pre><code class="hljs">     修饰符可以连续写，比如@click.stop.prevent 先阻止冒泡，再阻止默认事件</code></pre></div><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><div class="hljs code-wrapper"><pre><code class="hljs">  computed     1、定义：要用的属性不存在，要通过已有属性计算得来     2、原理：底层借助Object.defineProperty方法提供的getter和setter     3、在vue实例中要写在computed中     4、get函数什么时候会执行？           (1)当初次读取之时会执行一次，以后会调用缓存           （2）当依赖数据发生改变时，会再次被调用     5、优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试更方便     6、备注：            1、计算属性会直接到vue实例中，直接读取即可            2、如果计算属性要被修改，必须写set函数去响应，且set呀要引起依赖数据的变化</code></pre></div><h1 id="事件监视"><a href="#事件监视" class="headerlink" title="事件监视"></a>事件监视</h1><div class="hljs code-wrapper"><pre><code class="hljs">    监视属性wantch       1、当监视的属性发生变化时，回调函数会立即调用，进行相关操作       2、监听的属性必须存在，才能进行监视       3、监视的两种写法             （1）写在vue实例中，传入watch配置          （2）通过vm.$watch(监视属性，监视执行语句)</code></pre></div><h1 id="深度监视"><a href="#深度监视" class="headerlink" title="深度监视"></a>深度监视</h1><div class="hljs code-wrapper"><pre><code class="hljs">   （1）vue中的watch默认不检测内部属性值的改变（一层）   （2）配置deep：true可以检测到对象内部值的改变（多层）   （3）vue自身可以检测对象内部值的改变，但vue提供的watch默认不可以   （4）使用watch时根据数据的具体结构，决定是否采用是否采用深度监视</code></pre></div><h1 id="计算属性与监视属性的区别"><a href="#计算属性与监视属性的区别" class="headerlink" title="计算属性与监视属性的区别"></a>计算属性与监视属性的区别</h1><div class="hljs code-wrapper"><pre><code class="hljs">    computed和watch之间的区别：          1、computed能完成的功能，watch都可以完成          2、watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作    两个重要的小原则：          1、所有被vue管理的函数，最好写成普通函数，这样this的指向才是vm或组件化实例对象          2、所有不被vue所管理的函数（定时器的回调函数，ajax的回调函数，promise的回调函数）。最好写成箭头函数             这样this的指向才是vm或组件化对象</code></pre></div><h1 id="样式绑定"><a href="#样式绑定" class="headerlink" title="样式绑定"></a>样式绑定</h1><div class="hljs code-wrapper"><pre><code class="hljs">     1、class样式          写法   :class=&quot;xxx&quot;,xxx可以是字符串，对象，数组                字符串写法，适用于类名不确定，要动态获取                数组的写法，适用于要绑定多个样式，但个数不确定，名字也不确定                对象的写法，适用于要绑定多个样式，但个数去掉，名字确定，但不知道用不用    2、style样式          :style=&quot;&#123;fontSize:xxx&#125;&quot;,其中xxx是动态的          :style=&quot;[a,b]&quot;,其中a，b是样式对象</code></pre></div><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><div class="hljs code-wrapper"><pre><code class="hljs">    条件渲染有两个指令     1、v-show：           写法v-show:=&quot;表达式&quot;           适用于切换频率较高的场景           特点：不展示的DOM元素未被移出，仅仅是使用样式消失     2、v-if：           写法：              v-if=&quot;表达式&quot;              v-esle-if=&quot;表达式&quot;              v-else=&quot;表达式”           适用于切换频率较低的场景           特点：不展示的DOM元素直接被移出           注意：v-if可以和v-else-if、v-else一起使用，但要求结果不能被打断。</code></pre></div><h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><div class="hljs code-wrapper"><pre><code class="hljs">     v-for指令：           1、用于展示列表数据           2、语法v-for=&quot;(item,index) in xxx&quot; :key=&quot;xxx&quot;           3、可遍历：数组、对象、字符串、指定次数</code></pre></div><h1 id="面试题react、vue中的key有什么作用"><a href="#面试题react、vue中的key有什么作用" class="headerlink" title="面试题react、vue中的key有什么作用"></a>面试题react、vue中的key有什么作用</h1><h1 id="key的内部原理"><a href="#key的内部原理" class="headerlink" title="key的内部原理"></a>key的内部原理</h1><div class="hljs code-wrapper"><pre><code class="hljs">     1、虚拟DOM中key的作用：            key是虚拟DOM的数据标识，当数据发生改变时，vue会根据新数据生成新的虚拟DOM            随着vue进行新虚拟DOM与旧的虚拟DOM的差异比较，比较规则如下:(使用diff算法比较）     2、对比规则：           （1）旧的虚拟DOM中找到了与新的虚拟DOM相同的key：                 若虚拟DOM中的内容没变，直接使用之前的真实DOM                 若虚拟DOM中内容改变了，则生成新的真实DOM，随后替换掉页面中之前真实DOM           （2)旧的虚拟DOM未找到与新虚拟DOM相同的key                 创建真实的DOM，随后渲染到页面上     3、用index作为key可能引发的问题：            1、用数据进行：逆序添加、逆序删除等破坏顺序的操作                 会产生没有必要的真实DOM更新，===》页面效果没问题，但效率低            2、如果结构中包含输入类的DOM：                    会产生DOM的错误更新===》界面有问题     4、在开发中如何选择key             1、最好选择每条数据的唯一标识，比如id、电话号、身份证号等             2、如果不存在逆序添加、逆序删除、选择index也是没问题的</code></pre></div><h1 id="vue检测数据更新总结"><a href="#vue检测数据更新总结" class="headerlink" title="vue检测数据更新总结"></a>vue检测数据更新总结</h1><div class="hljs code-wrapper"><pre><code class="hljs">  1、vue会监视data中所有层次的数据  2、如何检测对象中的数据？       通过setter来实现监视，且要在new Vue时就要传入要检测的数据：        （1）.对象中后追加的属性，Vue默认不做响应式处理        （2）如需给后续添加的属性做响应式，请使用如下API：                Vue.set(target,&#39;property&#39;,&#39;value&#39;)               或者vm.$set(target,&#39;property&#39;,&#39;value&#39;)  3、如何检测数组中的数据        通过包裹数组更新元素的方法实现，本质就是做了两件事：          （1）调用原生方法对数组进行更新          （2）重新解析模板，进而更新页面  4、Vue中修改数组中的某个元素一定要用如下方法：         1、使用这些API：push(),pop(),shift(),unshift(),splice(),reverse(),sort()         2、Vue.set()或者vm.$set()   特别注意：Vue.set与vm.$set不能给vm或者vm的根数据添加属性（如data） </code></pre></div><h1 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h1><div class="hljs code-wrapper"><pre><code class="hljs">    为data添加getter与setter，对data加工，重新解析模板 </code></pre></div><h1 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h1><div class="hljs code-wrapper"><pre><code class="hljs">   若：&lt;input type=&quot;text&quot;&gt; :则v-model收集的是value值，用户输入的就是value值   若：&lt;input type=&quot;radio&quot;&gt;:则v-model收集的是value值，但是要给标签配置value值   若：&lt;input type=&quot;checkbox&quot;&gt;:        1、没有配置value值，v-model收集的就是checked（勾选 or 不勾选 是一个布尔值—）        2、配置了value值               但是value值为非数组，v-model收集的还是checked（勾选 or 不勾选 是一个布尔值—）             value为数组类型，v-model收集的就是value组成的数组   备注：v-model有三个修饰符          lazy：失去焦点在获取          number：输入字符串转化为有效数字          trim：输入首位空格过滤  </code></pre></div><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><div class="hljs code-wrapper"><pre><code class="hljs">   定义：对要显示的数据进行特定的格式化后在显示（适用于一些简单的逻辑处理）   语法：         1、注册过滤器：Vue.filter(name,callback)或者new Vue（filters:&#123;&#125;)        2、使用过滤器：&#123;&#123;xxx | 过滤器名&#125;&#125;或者v-bind：属性=&quot;xxx |过滤器名&quot;   备注：        1、概率器也可以接收额外 参数、多个过滤器也可以串联        2、并没有改变原本的数据，是产生新的对应数据  </code></pre></div><h1 id="截至目前我们学过的指令"><a href="#截至目前我们学过的指令" class="headerlink" title="截至目前我们学过的指令"></a>截至目前我们学过的指令</h1><div class="hljs code-wrapper"><pre><code class="hljs">    v-bind：单向绑定解析表达式，可简写为 :xxx    xxx是属性名    v-model：双向绑定数据    v-for：遍历数组/对象/字符串    v-on:绑定事件监听    v-if：条件渲染（动态控制节点是否存在）    v-show：条件渲染    v-else：条件渲染</code></pre></div><h1 id="其他内置指令"><a href="#其他内置指令" class="headerlink" title="其他内置指令"></a>其他内置指令</h1><div class="hljs code-wrapper"><pre><code class="hljs">    v-text指令：        1、作用：向其所在的节点渲染文本内容        2、与插值语法的区别：v-text会替换掉节点的内容，&#123;&#123;xx&#125;&#125;则不会    v-html指令：         1、作用：向指定的节点渲染包含html结构的内容         2、与插值语法的区别：             （1）v-html会替换掉节点中的所有内容，&#123;&#123;xx&#125;&#125;则不会             （2）v-html可以识别html结构         3、严重注意：v-html有安全性问题              （1）在网站中动态渲染任意html是非常危险的，容易导致xxs攻击              （2）一定要在可信的内容使用v-html，永远不要用在用户提交的内容上    v-cloak指令：          1、本质上是一个特殊的属性，Vue实例创建完毕之后接管容器，会删掉v-clock属性          2、使用css配合v-cloak可以解决网速较慢时页面展示不出来&#123;&#123;xxx&#125;&#125;的问题    v-once指令：          1、v-once所在节点在第一次动态渲染，就视为静态内容了          2、以后的数据更新改变就不会引起v-once所在结构的更新，可以用于性能优化    v-pre指令：          1、跳过其所在节点的编译过程          2、可利用它跳过：没有指令语法、没有插值语法的节点，会加快编译</code></pre></div><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><div class="hljs code-wrapper"><pre><code class="hljs">     局部指令定义语法：         new Vue(&#123;                                      new Vue(&#123;            directives:&#123;指令名：指令对象&#125;     或者            directives:&#123;指令名：回调函数&#125;          &#125;）                                            &#125;）          全局指令定义语法：         Vue.driective(指令名，回调函数）     二、配置对象常用的三个回调函数         （1）bind:指令与元素成功绑定时调用         （2）inserted：指令所在元素被插入页面时调用         （3）update：指令所在模板结构被重新调用     三、备注：         1、指令定义时不加v-，在使用时加v-         2、指令名如果是多个单词时，使用kebab-case类型定义，而不用cameLcase这种类型定义</code></pre></div><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><div class="hljs code-wrapper"><pre><code class="hljs">   生命周期：      1、又名，生命周期回调函数、生命周期函数、生命周期钩子      2、是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数      3、生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的      4、生命周期函数中的this指向的是vm实例对象或者组件化实例对象</code></pre></div><h1 id="生命周期函数钩子"><a href="#生命周期函数钩子" class="headerlink" title="生命周期函数钩子"></a>生命周期函数钩子</h1><div class="hljs code-wrapper"><pre><code class="hljs">   常用的生命函数钩子有：        1、mounted：发送AJAX请求、启动定时器、绑定自定义事件、订阅消息等初始化操作       2、beforedestroy：清除定时器、解绑自定义事件、取消订阅事件等收尾工作  关于销毁Vue实例       1、销毁后要借助Vue开发者工具看不到任何信息       2、销毁后的自定义事件会失效，但原生DOM依旧有效       3、一般不会在beforedestroy操作数据，因为即使操作数据，也不会触发更新数据。    </code></pre></div><h1 id="组件的概念"><a href="#组件的概念" class="headerlink" title="组件的概念"></a>组件的概念</h1><div class="hljs code-wrapper"><pre><code class="hljs">   实现应用中局部功能的代码和资源的集合</code></pre></div><h1 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h1><div class="hljs code-wrapper"><pre><code class="hljs">  Vue使用组件的三大步骤：       1、定义组件（创建组件）       2、注册组件       3、使用组件（写组件标签）  一、如何定义一个组件？       使用Vue.extend(options)创建，其中options和new Vue(options)传入那个options几乎一致，但也有区别            1、el不要写，--因为组件最终都要受到vm的管理，由vm中的el决定服务那个容器            2、data必须写成函数，----因为组件被复用时，数据存在引用关系。        备注：使用template可以配置组件结构   二、如何注册组件？        1、局部注册：靠new Vue的时候传入components选项        2、全局注册：Vue.component(&quot;组件名&quot;,组件）   三、编写组件标签？        例如：&lt;school&gt;&lt;/school&gt;</code></pre></div><h1 id="组件注意项"><a href="#组件注意项" class="headerlink" title="组件注意项"></a>组件注意项</h1><div class="hljs code-wrapper"><pre><code class="hljs">    1、关于组件名           如果时一个单词组成的话：               第一种写法（首字母小写）:school               第二种写法（首字母大写）：School           如果是多个单词组成：               第一种写法：my-school               第二种写法：MySchool（但是这种方法需要脚手架）           备注：             1、组件名要回避HTML中的标签名，如h2，button             2、可以在组件中使用name属性配置组件在开发者工具中的名字   2、关于组件标签          1、第一种写法：&lt;school&gt;&lt;/school&gt;          2、第二种写法：&lt;/school&gt;(但是这种不使用脚手架时，会导致此标签后续无法渲染   3、定义组件简写方式         const school=Vue.extend(options)  可简写为：const school=options          简写的原理是在注册组件时，Vue源码会进行判断，传入的对象，如果没有使用Vue.extend,就会帮程序员调用</code></pre></div><h1 id="关于VueComponent的五个点"><a href="#关于VueComponent的五个点" class="headerlink" title="关于VueComponent的五个点"></a>关于VueComponent的五个点</h1><div class="hljs code-wrapper"><pre><code class="hljs">   1、组件实质上是一个名为VueComponent的构造函数，并且不是由我们定义的，而是由Vue.extend()方法返回的（生成）   2、我们只需写&lt;school&gt;&lt;/school&gt;,Vue就会帮我们生成一个VueComponent实例对象，即Vue帮我们执行new VueComponent(options)   3、特别注意：每次调用Vue.extend,返回的都是一个全新的VueComponent   4、关于this的指向问题：           （1）组件配置中：                  data中的函数、methods中的函数、watch中的函数、computed中的函数，他们的this均是【VueComponent实例对象】           （2）new Vue（options）配置中：                  data中的函数、methods中的函数、watch中的函数、computed中的函数，他们的this均是【Vue实例对象】   5、VueComponent的实例对象，以后简称vc，（也可称之为组件实例对象）         Vue实例对象简称为vm</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码演示如果想手动将某些文章固定在首页靠前的位置</title>
      <link href="/2022/05/10/%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%BC%94%E7%A4%BA/"/>
      <url>/2022/05/10/%E4%BB%A3%E7%A0%81%E5%9D%97/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会</p><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br>犬瘟热太夫人法国和南非大家开个会<br><img src="https://cdn.jsdelivr.net/gh/hzx17/picgodemo/img/posts.jpg" alt="文章图片"></p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">//定义格式化时间的方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">dateFormat</span>(<span class="hljs-params">dateStr</span>)&#123;<br>  <span class="hljs-keyword">const</span> dt=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(dateStr)<br><br>  <span class="hljs-keyword">const</span> y=<span class="hljs-title function_">padZero</span>(dt.<span class="hljs-title function_">getFullYear</span>())<br>  <span class="hljs-keyword">const</span> m=<span class="hljs-title function_">padZero</span>(dt.<span class="hljs-title function_">getMonth</span>()+<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">const</span> d=<span class="hljs-title function_">padZero</span>(dt.<span class="hljs-title function_">getDate</span>())<br><br>  <span class="hljs-keyword">const</span> hh=<span class="hljs-title function_">padZero</span>(dt.<span class="hljs-title function_">getHours</span>())<br>  <span class="hljs-keyword">const</span> mm=<span class="hljs-title function_">padZero</span>(dt.<span class="hljs-title function_">getMinutes</span>())<br>  <span class="hljs-keyword">const</span> ss=<span class="hljs-title function_">padZero</span>(dt.<span class="hljs-title function_">getSeconds</span>())<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;y&#125;</span>-<span class="hljs-subst">$&#123;m&#125;</span>-<span class="hljs-subst">$&#123;d&#125;</span> <span class="hljs-subst">$&#123;hh&#125;</span>:<span class="hljs-subst">$&#123;mm&#125;</span>:<span class="hljs-subst">$&#123;ss&#125;</span>`</span><br>&#125;<br><span class="hljs-comment">//定义一个补零函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">padZero</span>(<span class="hljs-params">n</span>)&#123;<br>  <span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">9</span>? <span class="hljs-attr">n</span>:<span class="hljs-string">&#x27;0&#x27;</span>+n<br>&#125;<br><br><span class="hljs-comment">//向外暴露需要的成员</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>=&#123;<br>  dateFormat,<br>&#125;<br><br>&#123;% note success %&#125;<br>文字 或者 <span class="hljs-string">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br><br>&lt;p <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;标签&lt;/p&gt;<br></code></pre></div></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片名字</title>
      <link href="/2022/05/10/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%97/"/>
      <url>/2022/05/10/%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E5%90%8D%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" alt="图片名字的八个"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/10/hello-world/"/>
      <url>/2022/05/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo server<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo generate<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></div></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
